# Proposal: Garbage Collection (GC) for Flux

## Status
- Draft

## Summary
Introduce a simple, stop-the-world mark-and-sweep garbage collector to reclaim heap-allocated
objects (arrays, hashes, closures, and boxed values). This enables long-running programs and
prevents memory leaks from cyclic data structures.

## Motivation
- Current runtime relies on process exit for memory reclamation.
- Cycles (arrays/hashes/closures referencing each other) can leak indefinitely.
- Long-running or embedded Flux programs need predictable memory behavior.

## Goals
- Reclaim unreachable heap objects.
- Keep the runtime model simple and deterministic.
- Minimal changes to the public language surface.
- Allow incremental adoption (start with arrays/hashes).

## Non-Goals
- Concurrent or incremental GC.
- Moving/compacting GC in the first iteration.
- Precise tuning or generational heuristics initially.

## Proposed Design

### Heap Model
Introduce a GC heap that stores heap-allocated objects, referenced by handles.

```rust
enum HeapObject {
  Array(Vec<Object>),
  Hash(HashMap<HashKey, Object>),
  Some(Object),
  Left(Object),
  Right(Object),
  Closure(Closure),
  CompiledFunction(CompiledFunction),
}

struct HeapEntry {
  obj: HeapObject,
  marked: bool,
}
```

Objects in the VM become lightweight handles:

```rust
enum Object {
  // primitives unchanged
  Gc(HeapHandle),
}
```

### Roots
The collector marks from:
- VM stack (`stack[0..sp]`)
- VM globals (`globals`)
- Active frames (closures and constants)
- Module constants cache (if retained between runs)

### Mark Phase
Recursively traverse all objects reachable from roots and mark heap entries.

### Sweep Phase
Traverse heap entries and free those not marked. Unmark live objects for the next cycle.

### Trigger Strategy
Start with a simple threshold:
- Run GC when heap size exceeds N allocations.
- Allow `--gc` flag for forced collection.

## API Surface Changes
- No language syntax changes.
- Internal runtime changes only.

## Migration Plan (Incremental)
1) Add GC heap + allocation helpers.
2) Move `Array` and `Hash` to GC-managed objects.
3) Move `Some`, `Left`, `Right` to GC-managed objects.
4) Move `Closure` and `CompiledFunction` if needed.

## Testing Strategy
- Unit tests for mark/sweep correctness (reachable vs unreachable).
- Regression tests for cyclic structures.
- Memory leak tests with repeated allocations in loops.

## Risks
- Performance overhead (mitigate with simple thresholds).
- Complexity in refactoring Object/VM.
- Incorrect root tracing can cause use-after-free.

## Alternatives Considered
- Reference counting (simpler but fails on cycles).
- Arena allocation per program run (only works for short-lived runs).

## Open Questions
- Should GC be optional via a flag?
- Should compiled functions be GC-managed or interned?
- What default allocation threshold is acceptable?
