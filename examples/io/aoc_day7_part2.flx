// Advent of Code - Day 7 Part 2 (Laboratories)
// Quantum manifold: one particle, timelines split at each splitter (^).
// Count total completed timelines.
// Input: examples/io/aoc_day7.txt

fn line_at(arr, idx) {
    match arr[idx] {
        Some(v) -> v,
        _ -> ""
    }
}

fn int_at(arr, idx) {
    match arr[idx] {
        Some(v) -> v,
        _ -> 0
    }
}

fn char_at_pad(s, idx) {
    if idx < 0 || idx >= len(s) {
        " "
    } else {
        substring(s, idx, idx + 1)
    }
}

fn set_at(arr, idx, value) {
    let left = slice(arr, 0, idx)
    let right = slice(arr, idx + 1, len(arr))
    concat(concat(left, [|value|]), right)
}

fn add_at(arr, idx, delta) {
    if idx < 0 || idx >= len(arr) {
        arr
    } else {
        set_at(arr, idx, int_at(arr, idx) + delta)
    }
}

fn zeros(n) {
    map(range(0, n), \_ -> 0)
}

fn max_width(lines, i, cur) {
    if i >= len(lines) {
        cur
    } else {
        let w = len(line_at(lines, i))
        max_width(lines, i + 1, if w > cur { w } else { cur })
    }
}

fn find_s_in_row(s, i) {
    if i >= len(s) {
        -1
    } else {
        if substring(s, i, i + 1) == "S" {
            i
        } else {
            find_s_in_row(s, i + 1)
        }
    }
}

fn find_s(lines, r) {
    if r >= len(lines) {
        [|-1, -1|]
    } else {
        let c = find_s_in_row(line_at(lines, r), 0)
        if c >= 0 {
            [|r, c|]
        } else {
            find_s(lines, r + 1)
        }
    }
}

fn step_res(next_counts, finished) {
    let m = put({}, "next", next_counts)
    put(m, "done", finished)
}

fn step_next(x) {
    match get(x, "next") {
        Some(v) -> v,
        _ -> [||]
    }
}

fn step_done(x) {
    match get(x, "done") {
        Some(v) -> v,
        _ -> 0
    }
}

fn process_cols(row_txt, col, width, active_counts, next_counts, finished) {
    if col >= width {
        step_res(next_counts, finished)
    } else {
        let cnt = int_at(active_counts, col)
        if cnt == 0 {
            process_cols(row_txt, col + 1, width, active_counts, next_counts, finished)
        } else {
            let ch = char_at_pad(row_txt, col)
            if ch == "^" {
                let left_in = if col - 1 >= 0 { cnt } else { 0 }
                let right_in = if col + 1 < width { cnt } else { 0 }
                let out_left = if col - 1 < 0 { cnt } else { 0 }
                let out_right = if col + 1 >= width { cnt } else { 0 }
                let n1 = add_at(next_counts, col - 1, left_in)
                let n2 = add_at(n1, col + 1, right_in)
                process_cols(row_txt, col + 1, width, active_counts, n2, finished + out_left + out_right)
            } else {
                let stay_next = add_at(next_counts, col, cnt)
                process_cols(row_txt, col + 1, width, active_counts, stay_next, finished)
            }
        }
    }
}

fn simulate(lines, row_idx, width, active_counts, finished) {
    if row_idx >= len(lines) {
        finished + sum(active_counts)
    } else {
        let row_txt_sim = line_at(lines, row_idx)
        let next0 = zeros(width)
        let r = process_cols(row_txt_sim, 0, width, active_counts, next0, finished)
        simulate(lines, row_idx + 1, width, step_next(r), step_done(r))
    }
}

let input7 = read_lines("examples/io/aoc_day7.txt")
let width7 = max_width(input7, 0, 0)
let s7 = find_s(input7, 0)
let srow7 = int_at(s7, 0)
let scol7 = int_at(s7, 1)
let start_counts7 = add_at(zeros(width7), scol7, 1)
print(simulate(input7, srow7, width7, start_counts7, 0))
