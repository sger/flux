// Advent of Code - Day 6 Part 1 (Trash Compactor)
// Parse vertical problems separated by all-space columns.
// Input: examples/io/aoc_day6.txt

fn line_at(lines, idx) {
    match lines[idx] {
        Some(v) -> v,
        _ -> ""
    }
}

fn char_at_pad(s, idx) {
    if idx >= len(s) {
        " "
    } else {
        substring(s, idx, idx + 1)
    }
}

fn int_at(arr, idx) {
    match arr[idx] {
        Some(v) -> v,
        _ -> 0
    }
}

fn max_width(lines, idx, cur) {
    if idx >= len(lines) {
        cur
    } else {
        let w = len(line_at(lines, idx))
        max_width(lines, idx + 1, if w > cur { w } else { cur })
    }
}

fn is_blank_col(lines, col, row) {
    if row >= len(lines) {
        true
    } else {
        let s = line_at(lines, row)
        if char_at_pad(s, col) == " " {
            is_blank_col(lines, col, row + 1)
        } else {
            false
        }
    }
}

fn skip_blank_cols(lines, width, col) {
    if col >= width {
        col
    } else {
        if is_blank_col(lines, col, 0) {
            skip_blank_cols(lines, width, col + 1)
        } else {
            col
        }
    }
}

fn find_problem_end(lines, width, col) {
    if col >= width {
        col
    } else {
        if is_blank_col(lines, col, 0) {
            col
        } else {
            find_problem_end(lines, width, col + 1)
        }
    }
}

fn slice_padded(s, start, stop) {
    if start >= len(s) {
        ""
    } else {
        let end = if stop > len(s) { len(s) } else { stop }
        if end <= start {
            ""
        } else {
            substring(s, start, end)
        }
    }
}

fn sum_problem(lines, num_rows, row, start, stop, acc) {
    if row >= num_rows {
        acc
    } else {
        let token = trim(slice_padded(line_at(lines, row), start, stop))
        let v = parse_int(token)
        sum_problem(lines, num_rows, row + 1, start, stop, acc + v)
    }
}

fn prod_problem(lines, num_rows, row, start, stop, acc) {
    if row >= num_rows {
        acc
    } else {
        let token = trim(slice_padded(line_at(lines, row), start, stop))
        let v = parse_int(token)
        prod_problem(lines, num_rows, row + 1, start, stop, acc * v)
    }
}

fn eval_problem(lines, num_rows, start, stop) {
    let op_line = line_at(lines, num_rows)
    let op = trim(slice_padded(op_line, start, stop))
    if op == "*" {
        prod_problem(lines, num_rows, 0, start, stop, 1)
    } else {
        sum_problem(lines, num_rows, 0, start, stop, 0)
    }
}

fn solve_cols(lines, num_rows, width, col, total) {
    let c = skip_blank_cols(lines, width, col)
    if c >= width {
        total
    } else {
        let e = find_problem_end(lines, width, c)
        let v = eval_problem(lines, num_rows, c, e)
        solve_cols(lines, num_rows, width, e + 1, total + v)
    }
}

let lines = read_lines("examples/io/aoc_day6.txt")
let num_rows = len(lines) - 1
let width = max_width(lines, 0, 0)
print(solve_cols(lines, num_rows, width, 0, 0))
