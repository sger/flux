module Day03Solver {
    fn char_at(s, idx) {
        substring(s, idx, idx + 1)
    }

    fn starts_with_at(s, idx, token) {
        idx + len(token) <= len(s) && substring(s, idx, idx + len(token)) == token
    }

    fn is_digit(ch) {
        ch == "0" || ch == "1" || ch == "2" || ch == "3" || ch == "4" ||
        ch == "5" || ch == "6" || ch == "7" || ch == "8" || ch == "9"
    }

    fn take_digits_1_to_3(s, idx, count, acc) {
        if idx >= len(s) || count >= 3 {
            (acc, idx, count)
        } else {
            let ch = char_at(s, idx)
            if is_digit(ch) {
                take_digits_1_to_3(s, idx + 1, count + 1, acc + ch)
            } else {
                (acc, idx, count)
            }
        }
    }

    // Returns Some((value, next_idx)) when mul(X,Y) is valid at idx, otherwise None.
    fn parse_mul_at(s, idx) {
        if !starts_with_at(s, idx, "mul(") {
            None
        } else {
            let left = take_digits_1_to_3(s, idx + 4, 0, "")
            let left_text = left.0
            let after_left = left.1
            let left_count = left.2

            if left_count == 0 || after_left >= len(s) || char_at(s, after_left) != "," {
                None
            } else {
                let right = take_digits_1_to_3(s, after_left + 1, 0, "")
                let right_text = right.0
                let after_right = right.1
                let right_count = right.2

                if right_count == 0 || after_right >= len(s) || char_at(s, after_right) != ")" {
                    None
                } else {
                    Some((parse_int(left_text) * parse_int(right_text), after_right + 1))
                }
            }
        }
    }

    // Fold over indices while carrying parser state.
    // state = (next_idx_to_process, total)
    fn day03a_from_memory(memory) {
        state.1
        where indices = to_list(range(0, len(memory)))
        where state = fold(indices, (0, 0), \(st, i) -> {
            let next_idx = st.0
            let total = st.1

            if i != next_idx {
                st
            } else {
                match parse_mul_at(memory, i) {
                    Some(hit) -> (hit.1, total + hit.0),
                    _ -> (i + 1, total)
                }
            }
        })
    }

    // Fold variant for do()/don't() behavior.
    // state = (next_idx_to_process, enabled, total)
    fn day03b_from_memory(memory) {
        state.2
        where indices = to_list(range(0, len(memory)))
        where state = fold(indices, (0, true, 0), \(st, i) -> {
            let next_idx = st.0
            let enabled = st.1
            let total = st.2

            if i != next_idx {
                st
            } else {
                if starts_with_at(memory, i, "don't()") {
                    (i + 7, false, total)
                } else {
                    if starts_with_at(memory, i, "do()") {
                        (i + 4, true, total)
                    } else {
                        if enabled {
                            match parse_mul_at(memory, i) {
                                Some(hit) -> (hit.1, true, total + hit.0),
                                _ -> (i + 1, true, total)
                            }
                        } else {
                            (i + 1, false, total)
                        }
                    }
                }
            }
        })
    }

    // Backward-compatible aliases used by existing perf scripts/tests.
    fn day03a_from_memory_hof(memory) {
        day03a_from_memory(memory)
    }

    fn day03b_from_memory_hof(memory) {
        day03b_from_memory(memory)
    }
}
