// Advent of Code - Day 11 (Haskell-style translation)
// Inspired by AOC2025.Day11 day11a/day11b.
// Uses input file: examples/io/aoc_day11.txt

fn line_at(lines, idx) {
    match lines[idx] {
        Some(v) -> v,
        _ -> ""
    }
}

fn str_at(arr, idx) {
    match arr[idx] {
        Some(v) -> v,
        _ -> ""
    }
}

fn find_char_from(s, ch, idx) {
    if idx >= len(s) {
        -1
    } else {
        if substring(s, idx, idx + 1) == ch {
            idx
        } else {
            find_char_from(s, ch, idx + 1)
        }
    }
}

fn parse_graph(lines, idx, g) {
    if idx >= len(lines) {
        g
    } else {
        if line == "" {
            parse_graph(lines, idx + 1, g)
        } else if c < 0 {
            parse_graph(lines, idx + 1, g)
        } else {
            let name = trim(substring(line, 0, c))
            let outs = split(trim(substring(line, c + 1, len(line))), " ")
            parse_graph(lines, idx + 1, put(g, name, outs))
        }
        where line = trim(line_at(lines, idx))
        where c    = find_char_from(line, ":", 0)
    }
}

// (count, memo) tuple replaces the result/result_count/result_memo helpers.
// add_to_cache: shared by both paths_to_uncached and paths2_uncached.
fn add_to_cache(r, key) {
    (r.0, put(r.1, key, r.0))
}

fn sum_children(outs, i, graph, memo, end_node, acc) {
    if i >= len(outs) {
        (acc, memo)
    } else {
        let r = paths_to(str_at(outs, i), graph, memo, end_node)
        sum_children(outs, i + 1, graph, r.1, end_node, acc + r.0)
    }
}

fn paths_to_uncached(node, graph, memo, end_node) {
    match get(graph, node) {
        Some(outs) -> add_to_cache(sum_children(outs, 0, graph, memo, end_node, 0), node),
        _ -> (0, put(memo, node, 0)),
    }
}

fn paths_to(node, graph, memo, end_node) {
    if node == end_node {
        (1, memo)
    } else {
        match get(memo, node) {
            Some(v) -> (v, memo),
            _ -> paths_to_uncached(node, graph, memo, end_node)
        }
    }
}

fn day11a(graph) {
    paths_to("you", graph, {}, "out").0
}

fn bool_i(v) {
    if v { 1 } else { 0 }
}

fn state_mask(seen_dac, seen_fft) {
    bool_i(seen_dac) + (2 * bool_i(seen_fft))
}

fn state_key(node, mask) {
    join([|node, "#", to_string(mask)|], "")
}

fn sum_children2(outs, i, seen_dac, seen_fft, graph, memo, acc) {
    if i >= len(outs) {
        (acc, memo)
    } else {
        let r = paths_to2(str_at(outs, i), seen_dac, seen_fft, graph, memo)
        sum_children2(outs, i + 1, seen_dac, seen_fft, graph, r.1, acc + r.0)
    }
}

fn paths2_uncached(node, key, seen_dac, seen_fft, graph, memo) {
    match get(graph, node) {
        Some(outs) -> add_to_cache(sum_children2(outs, 0, seen_dac, seen_fft, graph, memo, 0), key),
        _ -> (0, put(memo, key, 0)),
    }
}

fn paths_to2(node, seen_dac0, seen_fft0, graph, memo) {
    let sd   = seen_dac0 || node == "dac"
    let sf   = seen_fft0 || node == "fft"
    let mask = state_mask(sd, sf)
    let key  = state_key(node, mask)
    if node == "out" {
        (if sd && sf { 1 } else { 0 }, memo)
    } else {
        match get(memo, key) {
            Some(v) -> (v, memo),
            _ -> paths2_uncached(node, key, sd, sf, graph, memo)
        }
    }
}

fn day11b(graph) {
    paths_to2("svr", false, false, graph, {}).0
}

let lines = read_lines("examples/io/aoc_day11.txt")
let graph = parse_graph(lines, 0, {})

print(day11a(graph))
print(day11b(graph))
